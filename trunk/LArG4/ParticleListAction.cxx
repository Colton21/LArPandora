////////////////////////////////////////////////////////////////////////
/// \file  ParticleListAction.cxx
/// \brief Use Geant4's user "hooks" to maintain a list of particles generated by Geant4.
///
/// \version $Id: ParticleListAction.cxx,v 1.8 2010/04/29 15:39:33 seligman Exp $
/// \author  seligman@nevis.columbia.edu
////////////////////////////////////////////////////////////////////////

#include "LArG4/ParticleListAction.h"
#include "G4Base/PrimaryParticleInformation.h"
#include "SimulationBase/simbase.h"
#include "Simulation/sim.h"

#include "messagefacility/MessageLogger/MessageLogger.h"

#include <G4Event.hh>
#include <G4Track.hh>
#include <G4ThreeVector.hh>
#include <G4ParticleDefinition.hh>
#include <G4PrimaryParticle.hh>
#include <G4DynamicParticle.hh>
#include <G4VUserPrimaryParticleInformation.hh>
#include <G4Step.hh>
#include <G4StepPoint.hh>
#include <G4VProcess.hh>
#include <G4String.hh>

#include <TLorentzVector.h>
#include <TString.h>

#include <algorithm>

const G4bool debug = false;

namespace larg4 {

  // Initialize static members.
  sim::Particle* ParticleListAction::fparticle       = 0;
  int            ParticleListAction::fCurrentTrackID = sim::NoParticleId;

  // Constructor.
  ParticleListAction::ParticleListAction(double energyCut, 
					 bool   storeTrajectories,
					 bool   keepEMShowerDaughters)
    : fenergyCut(energyCut * GeV)
    , fparticleList(0)
    , fstoreTrajectories(storeTrajectories)
    , fKeepEMShowerDaughters(keepEMShowerDaughters)
  {
    // Create the particle list that we'll (re-)use during the course
    // of the Geant4 simulation.
    fparticleList = new sim::ParticleList;
    fParentIDMap.clear();
  }

  // Destructor.
  ParticleListAction::~ParticleListAction()
  {
    // Delete anything that we created with "new'.
    delete fparticleList;
  }

  // Begin the event
  void ParticleListAction::BeginOfEventAction(const G4Event*)
  {
    // Clear any previous particle information.
    fparticle = 0;
    fparticleList->clear();
    fCurrentTrackID = sim::NoParticleId;
  }

  // Create our initial sim::Particle object and add it to the sim::ParticleList.
  void ParticleListAction::PreTrackingAction(const G4Track* track)
  {
    // Particle type.
    G4ParticleDefinition* particleDefinition = track->GetDefinition();
    G4int pdgCode = particleDefinition->GetPDGEncoding();

    // Get Geant4's ID number for this track.  This will be the same
    // ID number that we'll use in the ParticleList.
    G4int trackID = track->GetTrackID();
    fCurrentTrackID = trackID;
    // And the particle's parent:
    G4int parentID = track->GetParentID();

    art::Ptr<simb::MCTruth> primary;
    unsigned int primaryIndex = 0;

    // Is there an MCTruth object associated with this G4Track?  We
    // have to go up a "chain" of information to find out:
    const G4DynamicParticle* dynamicParticle = track->GetDynamicParticle();
    const G4PrimaryParticle* primaryParticle = dynamicParticle->GetPrimaryParticle();
    if ( primaryParticle != 0 ){
      const G4VUserPrimaryParticleInformation* gppi = primaryParticle->GetUserInformation();
      const g4b::PrimaryParticleInformation* ppi = dynamic_cast<const g4b::PrimaryParticleInformation*>(gppi);
      if ( ppi != 0 ){
	    // If we've made it this far, a PrimaryParticleInformation
	    // object exists.  If there's an MCTruth pointer in it
	    // (almost certainly the case, otherwise PPI object would
	    // never have been created in the first place) fetch the
	    // MCTruth pointer; if there's no MCTruth pointer,
	    // then this will get zero, which is still fine.
	    primary = ppi->GetMCTruth();
	    primaryIndex = ppi->GetMCTruthIndex();
      } // end else no primary particle information
    } // Is there a G4PrimaryParticle?
    // If this is not a primary particle...
    else{
      // check if this particle was made in an EM shower, don't put it in the particle 
      // list as we don't care about secondaries, tertiaries, etc for these showers
      // figure out what process is making this track - skip it if it is 
      // one of pair production, compton scattering, photoelectric effect
      // bremstrahlung, annihilation, any ionization - who wants to save
      // a buttload of electrons that arent from a CC interaction?
      std::string process_name = track->GetCreatorProcess()->GetProcessName();
      if( !fKeepEMShowerDaughters
	  && (process_name.find("conv")               != std::string::npos
	      || process_name.find("LowEnConversion") != std::string::npos
	      || process_name.find("Pair")            != std::string::npos
	      || process_name.find("compt")           != std::string::npos
	      || process_name.find("Compt")           != std::string::npos
	      || process_name.find("Brem")            != std::string::npos
	      || process_name.find("phot")            != std::string::npos
	      || process_name.find("Photo")           != std::string::npos
	      || process_name.find("Ion")             != std::string::npos
	      || process_name.find("annihil")         != std::string::npos)
	  ){
	
	// figure out the ultimate parentage of this particle
	// first add this track id and its parent to the fParentIDMap
	fParentIDMap[trackID] = parentID;
		
	// now search the map recursively until we have the parent id 
	// of the first EM particle that led to this one
	std::map<int,int>::const_iterator itr = fParentIDMap.find(trackID);
	while( itr != fParentIDMap.end() ){
	  // set the fCurrentTrackID to the current parent ID, when the loop ends
	  // this id will be the first EM particle 
	  fCurrentTrackID = (*itr).second;
	  itr = fParentIDMap.find((*itr).second);
	}
	
	// set fparticle to 0 as we are not stepping this particle and 
	// adding trajectory points to it
	fparticle = 0;
	return;
	
      } // end if keeping EM shower daughters

      // Check the energy of the particle.  If it falls below the energy
      // cut, don't add it to our list.
      G4double energy = track->GetKineticEnergy();
      if( energy < fenergyCut ){
	fparticle = 0;
	fCurrentTrackID = sim::NoParticleId;
	return;
      }
      
    }// end if not a primary particle

    // Get the physics process that created the particle. If this is a
    // primary particle, use "primary".
    std::string process("unknown");
    std::string material("unknown");
    std::string volume("unknown");
    if( primary.isNonnull() ){
      process = "primary";
    }
    else{
      const G4VProcess* creator = track->GetCreatorProcess();
      if ( creator == 0 )
	process = "unknown";
      else{
	const G4String name = creator->GetProcessName();
	process = std::string(name);
      }
    } // end else primary is empty

    // This is probably the PDG mass, but just in case:
    double mass = dynamicParticle->GetMass();

    //const art::Ptr<simb::MCTruth> prim(primary);
    // Create the sim::Particle object.
    fparticle = new sim::Particle( trackID, pdgCode, primary, 
				   // \todo uncomment following line once we are using ROOT v5.30+
				   //primaryIndex, 
				   process, parentID, mass);
    
    // Polarization.
    const G4ThreeVector& polarization = track->GetPolarization();
    fparticle->SetPolarization( TVector3( polarization.x(),
					  polarization.y(),
					  polarization.z() ) );

    // Save the particle in the ParticleList.
    fparticleList->Add( fparticle );
  }

  void ParticleListAction::PostTrackingAction( const G4Track* aTrack)
  {
    if(fparticle && aTrack){
      fparticle->SetWeight(aTrack->GetWeight());
    }

    return;
  }

  // With every step, add to the particle's trajectory.
  void ParticleListAction::SteppingAction(const G4Step* step)
  {
    if ( fparticle == 0 ) return;

    // For the most part, we just want to add the post-step
    // information to the particle's trajectory.  There's one
    // exception: In PreTrackingAction, the correct time information
    // is not available.  So add the correct vertex information here.

    if ( fparticle->NumberTrajectoryPoints() == 0 ){
      
      // Get the pre-step information from the G4Step.
      const G4StepPoint* preStepPoint = step->GetPreStepPoint();
      
      const G4ThreeVector position = preStepPoint->GetPosition();
      G4double time = preStepPoint->GetGlobalTime();
      
      // Remember that LArSoft uses cm, ns, GeV.
      TLorentzVector fourPos( position.x() / cm,
			      position.y() / cm,
			      position.z() / cm,
			      time / ns);
      
      const G4ThreeVector momentum = preStepPoint->GetMomentum();
      const G4double energy = preStepPoint->GetTotalEnergy();
      TLorentzVector fourMom( momentum.x() / GeV,
			      momentum.y() / GeV,
			      momentum.z() / GeV,
			      energy / GeV);
      
      // Add the first point in the trajectory.
      fparticle->AddTrajectoryPoint( fourPos, fourMom );
    } // end if this is the first step

    // At this point, the particle is being transported through the
    // simulation. This method is being called for every voxel that
    // the track passes through, but we don't want to update the
    // trajectory information if we're just updating voxels. To check
    // for this, look at the process name for the step, and compare it
    // against the voxelization process name (set in PhysicsList.cxx).
    G4String process = step->GetPostStepPoint()->GetProcessDefinedStep()->GetProcessName();
    G4bool ignoreProcess = process.contains("LArVoxel") || process.contains("PMTReadout"); 

    LOG_DEBUG("ParticleListAction::SteppingAction") << ": DEBUG - process='" 
						    << process << "'"
						    << " ignoreProcess=" << ignoreProcess
						    << " fstoreTrajectories=" 
						    << fstoreTrajectories;
    
    // We store the initial creation point of the particle 
    // and its final position (ie where it has no more energy, or at least < 1 eV) no matter
    // what, but whether we store the rest of the trajectory depends
    // on the process, and on a user switch.
    if ( fstoreTrajectories  &&  !ignoreProcess ){
      // Get the post-step information from the G4Step.
      const G4StepPoint* postStepPoint = step->GetPostStepPoint();
      
      const G4ThreeVector position = postStepPoint->GetPosition();
      G4double time = postStepPoint->GetGlobalTime();
      
      // Remember that LArSoft uses cm, ns, GeV.
      TLorentzVector fourPos( position.x() / cm,
			      position.y() / cm,
			      position.z() / cm,
			      time / ns );
      
      const G4ThreeVector momentum = postStepPoint->GetMomentum();
      const G4double energy = postStepPoint->GetTotalEnergy();
      TLorentzVector fourMom( momentum.x() / GeV,
			      momentum.y() / GeV,
			      momentum.z() / GeV,
			      energy / GeV );
      
      // Add another point in the trajectory.
      fparticle->AddTrajectoryPoint( fourPos, fourMom );
    }
  }

  /// Utility class for the EndOfEventAction method: update the
  /// daughter relationships in the particle list.
  class UpdateDaughterInformation
    : public std::unary_function<sim::ParticleList::value_type, void>
  {
  public:
    UpdateDaughterInformation()
      : particleList(0)
    {}
    void SetParticleList( sim::ParticleList* p ) { particleList = p; }
    void operator()( sim::ParticleList::value_type& particleListEntry )
    {
      // We're looking at this Particle in the list.
      sim::Particle* particle = particleListEntry.second;

      // The parent ID of this particle.
      int parentID = particle->Mother();

      // If the parentID <= 0, this is a primary particle.
      if ( parentID <= 0 ) return;

      // If we get here, this particle is somebody's daughter.  Add
      // it to the list of daughter particles for that parent.

      // Get the parent particle from the list.
      sim::ParticleList::iterator parentEntry = particleList->find( parentID );

      if ( parentEntry == particleList->end() ){
	// We have an "orphan": a particle whose parent isn't
	// recorded in the particle list.  This is not signficant;
	// it's possible for a particle not to be saved in the list
	// because it failed an energy cut, but for it to have a
	// daughter that passed the cut (e.g., a nuclear decay).
	return;
      }

      // Add the current particle to the daughter list of the
      // parent.
      sim::Particle* parent = (*parentEntry).second;
      parent->AddDaughter( particle->TrackId() );
    }
  private:
    sim::ParticleList* particleList;     
  };

  // There's one last thing to do: All the particles have their
  // parent IDs set (in PostTrackingAction), but we haven't set the
  // daughters yet.  That's done in this method.
  void ParticleListAction::EndOfEventAction(const G4Event*)
  {
    // Set up the utility class for the "for_each" algorithm.  (We only
    // need a separate set-up for the utility class because we need to
    // give it the pointer to the particle list.  We're using the STL
    // "for_each" instead of the C++ "for loop" because it's supposed
    // to be faster.
    UpdateDaughterInformation updateDaughterInformation;
    updateDaughterInformation.SetParticleList( fparticleList );

    // Update the daughter information for each particle in the list.
    std::for_each(fparticleList->begin(), 
                  fparticleList->end(), 
                  updateDaughterInformation);
  }
  
  // Returns the ParticleList accumulated during the current event.
  const sim::ParticleList* ParticleListAction::GetList() const
  {
    return fparticleList;
  }

} // namespace LArG4
